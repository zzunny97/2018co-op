# 버블 정렬

버블 정렬은 배열의 시작 부분에서 시작하여 첫 번째 요소가 두 번째 요소보다 큰 경우에만 첫 번째 두 요소를 교체하여 구현되는 정렬 알고리즘입니다. 그런 다음이 비교가 다음 쌍으로 이동되는 식으로 계속됩니다. 이것은 배열이 완전히 정렬 될 때까지 수행됩니다. 작은 항목은 배열의 시작 부분까지 천천히 "버블"합니다. 때때로이 알고리즘은 배열의 끝으로 가라 앉거나 더 무거운 요소 때문에 싱킹 정렬이라고도합니다.

##### 런타임 :
- 평균 : O(N^2)
- 최악 : O(N^2)

##### 메모리 :
- O(1)

### 구현 :

구현이 평균 및 최악의 런타임으로 표시되지 않는 것은 매우 비효율적 인 알고리즘임을 나타냅니다. 그러나 개념을 이해하면 간단한 정렬 알고리즘의 기본 사항을 이해하는 데 도움이됩니다.

버블 정렬은 매우 간단한 정렬 알고리즘입니다. 배열의 인접 요소 쌍을 비교하는 것으로 구성됩니다. 첫 번째 요소가 더 크면 스왑하고, 그렇지 않으면 아무 것도하지 않고 다음 비교를 수행합니다.
이것은 배열`n`번을 살펴봄으로써 이루어지며,`n`은 배열의 원소의 양입니다.

! [버블 정렬 알고리즘의 애니메이션 GIF] (https://s3.amazonaws.com/codecademy-content/programs/tdd-js/articles/BubbleSort.gif)

GIF는 이것보다 거꾸로 된 구현을 보여줍니다.

#### 예
우리는 배열`[5, 1, 4, 2, 8]`을 취하고 버블 정렬을 사용하여 배열을 가장 낮은 수에서 가장 큰 수로 정렬합니다. 각 단계에서 굵게 표시된 요소를 비교합니다. 세 번 통과해야합니다.

##### 첫 번째 패스
[ **5 1** 4 2 8 ] -> [ **1 5** 4 2 8 ], 여기서 알고리즘은 처음 두 요소를 비교하고 5> 1 이후로 스왑합니다.

[ 1 **5 4** 2 8 ] -> [ 1 **4 5** 2 8 ], 스왑 5 > 4

[ 1 4 **5 2** 8 ] -> [ 1 4 **2 5** 8 ], 스왑 5 > 2

[ 1 4 2 **5 8** ] -> [ 1 4 2 **5 8** ], 이제 이 원소들은 이미 순서대로 (8> 5) 있기 때문에 알고리즘은 그것들을 바꾸지 않습니다.

##### 두 번째 패스
[ **1 4** 2 5 8 ] -> [ **1 4** 2 5 8 ]

[ 1 **4 2** 5 8 ] -> [ 1 **2 4** 5 8 ], 스왑 4 > 2 

[ 1 2 **4 5** 8 ] -> [ 1 2 **4 5** 8 ]

[ 1 2 4 **5 8** ] -> [ 1 2 4 **5 8** ]
이제 배열은 이미 정렬되었지만 알고리즘이 완료되었는지는 알 수 없습니다. 알고리즘은 스왑없이 전체 패스 한 개가 정렬되어 있어야합니다.

##### 세 번째 패스
[ **1 2** 4 5 8 ] -> [ **1 2** 4 5 8 ]

[ 1 **2 4** 5 8 ] -> [ 1 **2 4** 5 8 ]

[ 1 2 **4 5** 8 ] -> [ 1 2 **4 5** 8 ]

[ 1 2 4 **5 8** ] -> [ 1 2 4 **5 8** ]

이것은 다섯 번째와 네 번째 패스에서 동일합니다.

#### 코드
```swift
for i in 0..<array.count {
  for j in 1..<array.count {
    if array[j] < array[j-1] {
      let tmp = array[j-1]
      array[j-1] = array[j]
      array[j] = tmp
    }
  }
}
return array
```

#### 최적화
버블 정렬 알고리즘은 'n 번째'패스가 'n 번째'가장 큰 요소를 찾아 최종 위치에 놓는 것을 관찰함으로써 쉽게 최적화 할 수 있습니다. 따라서 내부 루프는 'n 번째'시간 동안 실행될 때 마지막 'n-1'항목을 보는 것을 피할 수 있습니다.

```swift
for i in 0..<array.count {
  for j in 1..<array.count - i {
    if array[j] < array[j-1] {
      let tmp = array[j-1]
      array[j-1] = array[j]
      array[j] = tmp
    }
  }
}
return array
```
두 번째 줄에서 변경된 사항은`1 .. <array.count`에서`1 .. <array.count - i`로 간격을 변경하여 효과적으로 비교 횟수를 절반으로 줄였습니다.

최적화 된 코드의 순서는 배열`[5, 1, 4, 2, 8]`에서 다음과 같이 보입니다 :

##### 첫 번째 패스
[ **5 1** 4 2 8 ] -> [ **1 5** 4 2 8 ], 스왑 5 > 1

[ 1 **5 4** 2 8 ] -> [ 1 **4 5** 2 8 ], 스왑 5 > 4 

[ 1 4 **5 2** 8 ] -> [ 1 4 **2 5** 8 ], 스왑 5 > 2 

[ 1 4 2 **5 8** ] -> [ 1 4 2 **5 8** ], 이제 이 원소들은 이미 순서대로 (8> 5) 있기 때문에 알고리즘은 그것들을 바꾸지 않습니다.

* 첫 번째 패스가 끝날 때까지 마지막 요소가 가장 큰 것으로 보장됩니다 *

##### 두 번째 패스
[ **1 4** 2 5 8 ] -> [ **1 4** 2 5 8 ]

[ 1 **4 2** 5 8 ] -> [ 1 **2 4** 5 8 ], 스왑 4 > 2 

[ 1 2 **4 5** 8 ] -> [ 1 2 **4 5** 8 ], 첫 번째 루프가 한 번 발생 했으므로 내부 루프가 여기서 멈추고 5와 8을 비교하지 않습니다

##### 세 번째 패스
[ **1 2** 4 5 8 ] -> [ **1 2** 4 5 8 ]

[ 1 **2 4** 5 8 ] -> [ 1 **2 4** 5 8 ] 다시 한 번 짧은 비교

##### 넷째 패스
[ **1 2** 4 5 8 ] -> [ **1 2** 4 5 8 ]

다섯 번째 패스가 없습니다.

#### 결론

제안 된 최적화로도 이것은 여전히 ​​비효율적인 정렬 알고리즘입니다. 좋은 대안은 [Merge Sort] (https://github.com/raywenderlich/swift-algorithm-club/tree/master/Merge%20Sort)입니다. 이는 성능이 뛰어날뿐만 아니라 비슷한 정도의 구현이 가능하다는 것입니다.

* 훌리오 브라질 (Julio Brazil)의 스위프트 알고리즘 클럽 (Swift Algorithm Club)

##### 링크 지원
[Code Pumpkin] (https://codepumpkin.com/bubble-sort/)
[Wikipedia] (https://en.wikipedia.org/wiki/Bubble_sort)
[GeeksforGeeks] (https://www.geeksforgeeks.org/bubble-sort/)
